<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="pixel-er">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
      }

      :host ::content .output {
        margin: 20px auto;
        word-wrap: break-word;
      }
    </style>

    <canvas id="canvas" width="400" height="400" hidden></canvas>
    <img id="image" on-load="_onImageLoaded" hidden>
    <content id="content" select=".output"></content>

    <canvas id="palette">
  </template>

  <script>
    var canvasWidth = 600;

    Polymer({
      is: 'pixel-er',

      properties: {
        file: {
          type: Object,
          observer: '_fileChanged'
        },

        resolution: {
          type: Number,
          value: 50
        }
      },

      attached: function() {
        this._ctx = this.$.canvas.getContext('2d');

        // From https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/imageSmoothingEnabled
        this._ctx.mozImageSmoothingEnabled = false;
        this._ctx.msImageSmoothingEnabled = false;
        this._ctx.imageSmoothingEnabled = false;

        this.$.canvas.width = canvasWidth;

        //this._palette = ['üçã', 'üçë', 'üçé', 'üíé', 'üê¢', 'üôä', 'üêê', 'üç©'];
        this._emojiColorMap = {'ff0000': 'üçé', 'ffff00': 'üçã', '000000': 'üç©', 'ffffff': 'üêê'};
      },

      _fileChanged: function(file) {
        if (!this._reader) {
          this._reader = new FileReader();
          this._reader.onload = this._loadFile.bind(this);
        }
        this._reader.readAsDataURL(file);
      },

      _loadFile: function(event) {
        this.$.image.src = event.target.result;
        //filename.innerHTML = e.target.files[0].name;
      },

      _onImageLoaded: function(event) {
        var imageRatio = this.$.image.height / this.$.image.width;

        var pixelsPerWidth = this.resolution;
        var pixelsPerHeight = Math.floor(pixelsPerWidth * imageRatio);

        // Adjust the canvas to fit the shape of the image.
        this.$.canvas.height = Math.ceil(canvasWidth * imageRatio);

        this._displayPixelatedImage(pixelsPerWidth, pixelsPerHeight);
      },

      _displayPixelatedImage: function(pixelsPerWidth, pixelsPerHeight) {
        // Oopsies?
        if (!this.$.canvas.width || !this.$.canvas.height) {
          return;
        }

        var imageData = this._getPixellatedImageData(pixelsPerWidth, pixelsPerHeight);
        var colors = this._getPixelColors(imageData, pixelsPerWidth, pixelsPerHeight);

        // I don't love this.
        var container = Polymer.dom(this.$.content).getDistributedNodes()[0];

        // Remove the previous render and redisplay the new image.
        container.innerHTML = '';
        container.style.width = this.$.canvas.width +'px';
        container.style.height = this.$.canvas.height +'px';

        var fragment = document.createDocumentFragment();

        var pixelWidth = this.$.canvas.width / pixelsPerWidth;
        var pixelHeight = this.$.canvas.height / pixelsPerHeight

        for (var i = 0; i < colors.length; i++) {
          var pixel = this._drawPixel(colors[i], pixelWidth, pixelHeight);

          fragment.appendChild(pixel);

          // Add a <br> at the end of every row so that we can copy paste this
          // as a grid.
          if (i % pixelsPerWidth === (pixelsPerWidth - 1)) {
            fragment.appendChild(document.createElement('br'));
          }
        }
        container.appendChild(fragment);
      },

      _getPixellatedImageData: function(pixelsPerWidth, pixelsPerHeight) {
        // Draw the image super tiny and then scale it from the tiny size
        // to the actual canvas size, which pixellates it.
        this._ctx.drawImage(this.$.image, 0, 0, pixelsPerWidth, pixelsPerHeight);
        this._ctx.drawImage(this.$.canvas,
                     0, 0, pixelsPerWidth, pixelsPerHeight,          /* source */
                     0, 0, this.$.canvas.width, this.$.canvas.height /* dest */);

        return this._ctx.getImageData(0, 0, this.$.canvas.width, this.$.canvas.height);
      },

      _getPixelColors: function(imageData, pixelsPerWidth, pixelsPerHeight) {
        function getRGBA(data) {
          return 'rgba(' + data[0] + ',' + data[1] +
                  ',' + data[2] + ',' + data[3] + ')';
        }

        var colors = [];
        var widthRatio = canvas.width / pixelsPerWidth;
        var heightRatio = canvas.height / pixelsPerHeight;

        // How many original pixels we have in a "drawn" final pixel.
        for (var j = 0; j < pixelsPerHeight; j++) {
          for (var i = 0; i < pixelsPerWidth; i++) {
            var x = Math.round(widthRatio * i + 1) * 4;
            var y = Math.round(heightRatio * j + 1) * canvas.width * 4;

            var pixel = [imageData.data[y + x], imageData.data[y + x + 1], imageData.data[y + x + 2], imageData.data[y + x + 3]];
            var rgba = getRGBA(pixel);

            colors.push(rgba);
          }
        }
        return colors;
      },

      _drawPixel: function(rgba, size) {
        var pixel = document.createElement('span');
        pixel.className = 'pixel';
        pixel.style.display = 'inline-block';
        pixel.style.width = pixel.style.height = size + 'px';
        pixel.style.fontSize = size - 2 + 'px';
        pixel.style.backgroundColor = rgba;
        pixel.textContent = this._getClosestEmoji(rgba);
        return pixel;
      },

      _getClosestEmoji: function(rgba) {
        var split = rgba.replace('rgba(', '').replace(')', '').split(',');
        var minDistance = 10000000;
        var minKey = null;

        for (var emoji in this._emojiColorMap) {
          var rgb = this._hexToRgb(emoji);

          var distance =
              3 * Math.abs(rgb.r - split[0]) +
              4 * Math.abs(rgb.g - split[1]) +
              3 * Math.abs(rgb.b - split[2]);
          if (distance < minDistance) {
            minDistance = distance;
            minKey = emoji;
          }
        }

        return this._emojiColorMap[minKey];
      },

      _hexToRgb: function(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
      }

    });
  </script>
</dom-module>
